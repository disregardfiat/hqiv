<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>HQIV 3D Cellular Automaton — Light-Cone Mode Quantization</title>
<style>
  body { margin:0; background:#000; overflow:hidden; font-family:'Courier New',monospace; }
  #overlay { position:absolute; top:10px; left:10px; color:#0f0; z-index:100; 
             background:rgba(0,0,0,0.8); padding:12px; border:1px solid #0a0; border-radius:4px; min-width:320px; }
  #overlay h3 { margin:0 0 8px 0; color:#0ff; font-size:14px; }
  .stat { margin:3px 0; font-size:12px; }
  .highlight { color:#ff0; font-weight:bold; }
  .checkpoint { color:#f0f; animation:pulse 0.5s infinite; }
  @keyframes pulse { 0%{opacity:1;} 50%{opacity:0.5;} 100%{opacity:1;} }
  #controls { position:absolute; bottom:10px; left:10px; color:#888; font-size:11px; }
  #error { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); color:#f66; 
           font-size:18px; text-align:center; display:none; }
  #anisotropy { position:absolute; top:10px; right:10px; color:#0ff; z-index:100;
                background:rgba(0,0,0,0.8); padding:12px; border:1px solid #0ff; border-radius:4px; display:none; }
  #anisotropy h3 { margin:0 0 8px 0; font-size:14px; }
  #anisotropy canvas { display:block; margin-top:8px; border:1px solid #333; }
  .aniso-stat { font-size:11px; color:#888; margin-top:4px; }
  .aniso-stats { font-size:10px; color:#0ff; margin-top:8px; line-height:1.4; }
  .aniso-stats span { color:#ff0; }
  #downloadBtn { margin-top:8px; padding:4px 12px; background:#0a0; color:#000; border:none; 
                 cursor:pointer; font-family:inherit; font-size:11px; }
  #downloadBtn:hover { background:#0f0; }
</style>
</head>
<body>
<div id="overlay">
  <h3>HQIV Light-Cone Mode + Angular Momentum</h3>
  <div class="stat" id="stat-gen">Generation: 0</div>
  <div class="stat" id="stat-modes">Allowed Modes: 0</div>
  <div class="stat" id="stat-coherence">Angular Coherence: 0.000</div>
  <div class="stat" id="stat-time">Time: 0.00 Kyr</div>
  <div class="stat" id="stat-horizon">Horizon Θ: 0.0 Mpc</div>
  <div class="stat" id="stat-structure">Max Structure: 0.0 Mpc</div>
  <div class="stat" id="stat-bulk">Bulk Energy: 0.0%</div>
  <div class="stat checkpoint" id="stat-recomb" style="display:none;">★ RECOMBINATION - PAUSED ★</div>
</div>
<div id="anisotropy">
  <h3>CMB Anisotropy Map (Mollweide)</h3>
  <canvas id="anisoCanvas" width="512" height="256"></canvas>
  <div class="aniso-stats" id="aniso-stats"></div>
  <button id="downloadBtn" onclick="downloadAnisotropyData()">Download FITS-like Data</button>
</div>
<div id="controls">Drag: rotate • Scroll: zoom • Space: pause/resume • R: reset • A: anisotropy</div>
<div id="error">WebGL not available. Save as .html and open in Chrome/Firefox.</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
<script>
// ============================================================
// HQIV 3D Cellular Automaton - Light-Cone Mode Quantization
// Steven Ettinger + Mr 4.20
// ============================================================

// Increased resolution: 80^3 = 512,000 cells for l~1200 anisotropy
const GRID_SIZE = 80;
const CELL_SIZE = 1.0;
const MPc_to_grid = 0.15;
const RECOMB_TAU = 0.51;
const DAMPING_OUTSIDE = 0.85;
const ENERGY_THRESHOLD = 0.05;
const PRINT_EVERY = 3;

let energy, velocityX, velocityY, velocityZ, inertia;
let gridSize = GRID_SIZE;
let generation = 0;
let simTime = 0;
let paused = false;
let recombinationReached = false;
let recombinationSnapshot = null;

let scene, camera, renderer, points, horizonSphere;
let maxStructureSize = 0;
let cameraDir = new THREE.Vector3(0, 0, -1);
let anisotropyData = null; // Store for download

function initArrays() {
  const n = gridSize * gridSize * gridSize;
  energy = new Float32Array(n);
  velocityX = new Float32Array(n);
  velocityY = new Float32Array(n);
  velocityZ = new Float32Array(n);
  inertia = new Float32Array(n);
  
  // Smaller initial horizon for more sparse early modes
  const earlyHorizon = 3;
  for(let i=0; i<n; i++) {
    let x = (i % gridSize) - gridSize/2;
    let y = (Math.floor(i/gridSize) % gridSize) - gridSize/2;
    let z = Math.floor(i/(gridSize*gridSize)) - gridSize/2;
    let r = Math.sqrt(x*x + y*y + z*z);
    
    if (r < earlyHorizon) {
      energy[i] = 0.9 + Math.random() * 0.3;
      let mag = 0.06;
      let theta = Math.random() * Math.PI * 2;
      let phi = Math.random() * Math.PI;
      velocityX[i] = mag * Math.sin(phi) * Math.cos(theta);
      velocityY[i] = mag * Math.sin(phi) * Math.sin(theta);
      velocityZ[i] = mag * Math.cos(phi);
      inertia[i] = 0.5 + Math.random() * 0.5;
    } else {
      energy[i] = 0.01 + Math.random() * 0.02;
      velocityX[i] = 0;
      velocityY[i] = 0;
      velocityZ[i] = 0;
      inertia[i] = 1.0;
    }
  }
  console.log('Initialized ' + n + ' cells at ' + gridSize + '^3 resolution');
}

function getHorizonRadius(timeKyr) {
  let t_norm = Math.max(timeKyr, 1) / RECOMB_TAU;
  let baseHorizon = 164;
  return baseHorizon * Math.pow(t_norm, 0.67);
}

function getScaleFactor(timeKyr) {
  let t_norm = Math.max(timeKyr, 1) / RECOMB_TAU;
  return Math.pow(t_norm, 0.67);
}

function getNeighbors(i) {
  let x = i % gridSize;
  let y = Math.floor(i/gridSize) % gridSize;
  let z = Math.floor(i/(gridSize*gridSize));
  let neighbors = [];
  
  if (x > 0) neighbors.push(i - 1);
  if (x < gridSize-1) neighbors.push(i + 1);
  if (y > 0) neighbors.push(i - gridSize);
  if (y < gridSize-1) neighbors.push(i + gridSize);
  if (z > 0) neighbors.push(i - gridSize*gridSize);
  if (z < gridSize-1) neighbors.push(i + gridSize*gridSize);
  
  return neighbors;
}

function getCellCoord(i) {
  return {
    x: (i % gridSize) - gridSize/2,
    y: (Math.floor(i/gridSize) % gridSize) - gridSize/2,
    z: Math.floor(i/(gridSize*gridSize)) - gridSize/2
  };
}

function isInBulk(i) {
  let c = getCellCoord(i);
  let dist = Math.sqrt(c.x*c.x + c.y*c.y + c.z*c.z);
  return dist < gridSize * 0.35;
}

function updateCA() {
  if (paused) return;
  
  generation++;
  simTime += 1.5; // Slower for better resolution
  
  let horizonRadius = getHorizonRadius(simTime);
  let horizonGrid = horizonRadius * MPc_to_grid;
  let scaleFactor = getScaleFactor(simTime);
  
  const n = gridSize * gridSize * gridSize;
  let newEnergy = new Float32Array(n);
  let totalVx = 0, totalVy = 0, totalVz = 0;
  let allowedModes = 0;
  let bulkCells = 0;
  let bulkLowEnergy = 0;
  
  for(let i=0; i<n; i++) {
    let c = getCellCoord(i);
    let r = Math.sqrt(c.x*c.x + c.y*c.y + c.z*c.z);
    let insideHorizon = r < horizonGrid;
    let e = energy[i];
    let vx = velocityX[i];
    let vy = velocityY[i];
    let vz = velocityZ[i];
    
    let neighbors = getNeighbors(i);
    let neighborEnergy = 0;
    let neighborVx = 0, neighborVy = 0, neighborVz = 0;
    
    for(let ni of neighbors) {
      neighborEnergy += energy[ni];
      neighborVx += velocityX[ni];
      neighborVy += velocityY[ni];
      neighborVz += velocityZ[ni];
    }
    let numNeighbors = neighbors.length;
    if (numNeighbors > 0) {
      neighborEnergy /= numNeighbors;
      neighborVx /= numNeighbors;
      neighborVy /= numNeighbors;
      neighborVz /= numNeighbors;
    }
    
    let newE = e;
    
    if (insideHorizon) {
      if (e > ENERGY_THRESHOLD) {
        let densityDiff = neighborEnergy - e;
        newE += densityDiff * 0.08 * scaleFactor;
        
        vx = vx * 0.92 + neighborVx * 0.08;
        vy = vy * 0.92 + neighborVy * 0.08;
        vz = vz * 0.92 + neighborVz * 0.08;
        
        let inertiaReduction = 1.0 - 0.15 * Math.min(1, (e - ENERGY_THRESHOLD) * 3);
        vx *= inertiaReduction;
        vy *= inertiaReduction;
        vz *= inertiaReduction;
      }
      
      newE += 0.001 * scaleFactor;
      
      let zBias = 0.0003 * (1.0 + generation * 0.00005);
      vz += zBias;
    } else {
      newE *= DAMPING_OUTSIDE;
      vx *= DAMPING_OUTSIDE;
      vy *= DAMPING_OUTSIDE;
      vz *= DAMPING_OUTSIDE;
    }
    
    newE = Math.max(0.01, newE);
    newE = Math.min(2.0, newE);
    
    newEnergy[i] = newE;
    velocityX[i] = vx;
    velocityY[i] = vy;
    velocityZ[i] = vz;
    
    if (isInBulk(i)) {
      bulkCells++;
      if (newE < ENERGY_THRESHOLD * 1.5) {
        bulkLowEnergy++;
      }
    }
    
    if (insideHorizon && newE > ENERGY_THRESHOLD) {
      allowedModes++;
      totalVx += vx;
      totalVy += vy;
      totalVz += vz;
    }
  }
  
  energy = newEnergy;
  
  // Recombination trigger: time-based at ~380 Kyr (midpoint of 300-600 Kyr range)
  // This corresponds to z~1100 when the universe became transparent
  // Only trigger if we have meaningful structure formation (allowedModes > 0)
  let bulkFraction = bulkCells > 0 ? bulkLowEnergy / bulkCells : 0;
  let recombinationTime = simTime >= 380;
  let hasStructure = allowedModes > 1000;
  
  if (!recombinationReached && recombinationTime && hasStructure) {
    recombinationReached = true;
    paused = true; // Auto-pause at recombination!
    document.getElementById('stat-recomb').style.display = 'block';
    console.log('★ RECOMBINATION at ' + simTime.toFixed(1) + ' Kyr (bulk: ' + (bulkFraction*100).toFixed(1) + '%, modes: ' + allowedModes + ') ★');
    recombinationSnapshot = {
      energy: new Float32Array(energy),
      time: simTime,
      generation: generation
    };
    generateAnisotropyMap();
  }
  
  let coherence = 0;
  if (allowedModes > 0) {
    let avgVx = totalVx / allowedModes;
    let avgVy = totalVy / allowedModes;
    let avgVz = totalVz / allowedModes;
    let mag = Math.sqrt(avgVx*avgVx + avgVy*avgVy + avgVz*avgVz) + 0.0001;
    coherence = Math.abs(avgVz) / mag;
  }
  
  maxStructureSize = calculateMaxStructure() * (CELL_SIZE / MPc_to_grid) * 0.7;
  horizonSphere.scale.setScalar(horizonGrid * CELL_SIZE * 0.6);
  
  if (generation % PRINT_EVERY === 0) {
    updateStats(allowedModes, coherence, horizonRadius, bulkFraction);
  }
  
  updateVisualization();
}

function calculateMaxStructure() {
  const n = gridSize * gridSize * gridSize;
  let visited = new Uint8Array(n);
  let maxSize = 0;
  
  for(let i=0; i<n; i++) {
    if (energy[i] > ENERGY_THRESHOLD && !visited[i]) {
      let size = 0;
      let queue = [i];
      visited[i] = 1;
      
      while(queue.length > 0) {
        let curr = queue.shift();
        size++;
        
        let neighbors = getNeighbors(curr);
        for(let ni of neighbors) {
          if (energy[ni] > ENERGY_THRESHOLD && !visited[ni]) {
            visited[ni] = 1;
            queue.push(ni);
          }
        }
      }
      maxSize = Math.max(maxSize, size);
    }
  }
  
  return Math.pow(maxSize, 1/3);
}

function updateStats(modes, coherence, horizon, bulkFrac) {
  document.getElementById('stat-gen').textContent = 'Generation: ' + generation;
  document.getElementById('stat-modes').textContent = 'Modes: ' + modes.toLocaleString();
  document.getElementById('stat-coherence').textContent = 'Coherence: ' + coherence.toFixed(4);
  document.getElementById('stat-time').textContent = 'Time: ' + simTime.toFixed(1) + ' Kyr';
  document.getElementById('stat-horizon').textContent = 'Horizon: ' + horizon.toFixed(1) + ' Mpc';
  document.getElementById('stat-structure').textContent = 'Structure: ' + maxStructureSize.toFixed(1) + ' Mpc';
  document.getElementById('stat-bulk').textContent = 'Bulk: ' + (bulkFrac * 100).toFixed(1) + '%';
  
  let cohEl = document.getElementById('stat-coherence');
  if (coherence > 0.6) {
    cohEl.classList.add('highlight');
  } else {
    cohEl.classList.remove('highlight');
  }
}

function updateVisualization() {
  const positions = points.geometry.attributes.position.array;
  const colors = points.geometry.attributes.color.array;
  
  camera.getWorldDirection(cameraDir);
  
  // Calculate mean energy for distance-to-mean coloring
  const n = gridSize * gridSize * gridSize;
  let meanEnergy = 0;
  let stdDev = 0;
  
  for(let i=0; i<n; i++) {
    meanEnergy += energy[i];
  }
  meanEnergy /= n;
  
  for(let i=0; i<n; i++) {
    stdDev += Math.pow(energy[i] - meanEnergy, 2);
  }
  stdDev = Math.sqrt(stdDev / n) + 0.001; // Avoid division by zero
  
  for(let i=0; i<gridSize*gridSize*gridSize; i++) {
    let c = getCellCoord(i);
    
    positions[i*3] = c.x * CELL_SIZE;
    positions[i*3+1] = c.y * CELL_SIZE;
    positions[i*3+2] = c.z * CELL_SIZE;
    
    let e = energy[i];
    let vx = velocityX[i];
    let vy = velocityY[i];
    let vz = velocityZ[i];
    
    let vMag = Math.sqrt(vx*vx + vy*vy + vz*vz) + 0.0001;
    let vDir = new THREE.Vector3(vx, vy, vz).normalize();
    let dot = vDir.dot(cameraDir);
    
    // Distance-to-mean based brightness (scale-corrected)
    // Values above mean are bright, below mean are dim
    let deviation = (e - meanEnergy) / stdDev;
    let brightness = 0.5 + deviation * 0.3; // Center at 0.5, scale by std devs
    brightness = Math.max(0.1, Math.min(1.0, brightness));
    
    let r, g, b;
    if (dot > 0) {
      r = brightness * (0.3 + dot * 0.7);
      g = brightness * 0.7 * (1 - dot);
      b = brightness * 0.8 * (1 - dot * 0.5);
    } else {
      r = brightness * 0.3 * (1 + dot);
      g = brightness * (0.7 - dot * 0.3);
      b = brightness * 0.8;
    }
    
    colors[i*3] = r;
    colors[i*3+1] = g;
    colors[i*3+2] = b;
  }
  
  points.geometry.attributes.position.needsUpdate = true;
  points.geometry.attributes.color.needsUpdate = true;
}

// Mollweide projection for CMB anisotropy
function mollweide(lon, lat, width, height) {
  // Standard Mollweide projection
  const lambda = lon;  // longitude in radians
  const phi = lat;     // latitude in radians
  
  if (Math.abs(phi) > Math.PI / 2) return null;
  
  // Solve for theta iteratively: 2*theta + sin(2*theta) = PI * sin(phi)
  let theta = phi; // Initial guess
  for (let i = 0; i < 10; i++) {
    let delta = (2 * theta + Math.sin(2 * theta) - Math.PI * Math.sin(phi)) / 
                (2 + 2 * Math.cos(2 * theta));
    theta -= delta;
    if (Math.abs(delta) < 1e-6) break;
  }
  
  const R = Math.min(width, height) * 0.45;
  
  // Standard Mollweide formulas
  const x = R * 2 * Math.SQRT2 / Math.PI * lambda * Math.cos(theta);
  const y = R * Math.SQRT2 * Math.sin(theta);
  
  return {
    x: width / 2 + x,
    y: height / 2 - y
  };
}

function generateAnisotropyMap() {
  if (!recombinationSnapshot) return;
  
  document.getElementById('anisotropy').style.display = 'block';
  
  const canvas = document.getElementById('anisoCanvas');
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;
  
  // Black background
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, width, height);
  
  // Draw Mollweide grid lines
  ctx.strokeStyle = '#222';
  ctx.lineWidth = 1;
  
  // Latitude lines
  for (let lat of [-60, -30, 0, 30, 60]) {
    let rad = lat * Math.PI / 180;
    ctx.beginPath();
    for (let lon = -Math.PI; lon <= Math.PI; lon += 0.02) {
      let pt = mollweide(lon, rad, width, height);
      if (pt) {
        if (lon === -Math.PI) ctx.moveTo(pt.x, pt.y);
        else ctx.lineTo(pt.x, pt.y);
      }
    }
    ctx.stroke();
  }
  
  // Longitude lines
  for (let lon of [-120, -60, 0, 60, 120]) {
    let rad = lon * Math.PI / 180;
    ctx.beginPath();
    for (let lat = -Math.PI/2; lat <= Math.PI/2; lat += 0.02) {
      let pt = mollweide(rad, lat, width, height);
      if (pt) {
        if (lat === -Math.PI/2) ctx.moveTo(pt.x, pt.y);
        else ctx.lineTo(pt.x, pt.y);
      }
    }
    ctx.stroke();
  }
  
  // Create a grid of angular directions for the CMB map
  // Each direction accumulates energy along the line of sight (like real CMB observation)
  const nTheta = 180; // longitude resolution
  const nPhi = 90;    // latitude resolution
  
  // Accumulate energy for each angular direction
  let energyMap = new Float32Array(nTheta * nPhi);
  let countMap = new Uint32Array(nTheta * nPhi);
  
  // Project ALL cells onto the sphere by their angular direction
  for (let i = 0; i < gridSize*gridSize*gridSize; i++) {
    let c = getCellCoord(i);
    let dx = c.x;
    let dy = c.y;
    let dz = c.z;
    let dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
    
    // Only consider cells inside the bulk region
    if (dist > 0 && dist < gridSize * 0.4) {
      // Calculate angular position
      let theta = Math.atan2(dy, dx); // -PI to PI
      let phi = Math.acos(dz / dist); // 0 to PI
      
      // Convert to grid indices
      let thetaIdx = Math.floor(((theta + Math.PI) / (2 * Math.PI)) * nTheta);
      let phiIdx = Math.floor((phi / Math.PI) * nPhi);
      
      thetaIdx = Math.max(0, Math.min(nTheta - 1, thetaIdx));
      phiIdx = Math.max(0, Math.min(nPhi - 1, phiIdx));
      
      let idx = phiIdx * nTheta + thetaIdx;
      energyMap[idx] += recombinationSnapshot.energy[i];
      countMap[idx]++;
    }
  }
  
  // Convert to samples array for processing
  const samples = [];
  let minE = Infinity, maxE = -Infinity;
  
  for (let phiIdx = 0; phiIdx < nPhi; phiIdx++) {
    for (let thetaIdx = 0; thetaIdx < nTheta; thetaIdx++) {
      let idx = phiIdx * nTheta + thetaIdx;
      if (countMap[idx] > 0) {
        let avgEnergy = energyMap[idx] / countMap[idx];
        let theta = (thetaIdx / nTheta) * 2 * Math.PI - Math.PI;
        let phi = (phiIdx / nPhi) * Math.PI;
        
        samples.push({theta, phi, energy: avgEnergy});
        minE = Math.min(minE, avgEnergy);
        maxE = Math.max(maxE, avgEnergy);
      }
    }
  }
  
  // Calculate mean and standard deviation from the SAMPLES themselves
  let meanE = 0;
  for (let s of samples) {
    meanE += s.energy;
  }
  meanE /= samples.length;
  
  let stdDev = 0;
  for (let s of samples) {
    stdDev += Math.pow(s.energy - meanE, 2);
  }
  stdDev = Math.sqrt(stdDev / samples.length);
  
  // Use min-max range if stdDev is too small
  let range = maxE - minE;
  let useMinMax = stdDev < 0.0001 || range < 0.0001;
  
  console.log('Anisotropy stats: mean=' + meanE.toFixed(6) + ', std=' + stdDev.toFixed(6) + 
              ', min=' + minE.toFixed(6) + ', max=' + maxE.toFixed(6) + 
              ', range=' + range.toFixed(6) + ', samples=' + samples.length);
  
  // Draw samples with proper color mapping - use larger pixels for visibility
  for (let s of samples) {
    let pt = mollweide(s.theta, s.phi - Math.PI/2, width, height);
    if (pt && pt.x > 0 && pt.x < width && pt.y > 0 && pt.y < height) {
      let norm;
      if (range > 0) {
        // Use min-max normalization scaled to -1 to +1
        norm = (s.energy - minE) / range - 0.5;
        norm *= 2;
      } else {
        norm = 0;
      }
      norm = Math.max(-1, Math.min(1, norm));
      
      // Enhanced CMB-style colormap with better contrast
      let r, g, b;
      if (norm < 0) {
        // Cold: deep blue to light blue
        let t = -norm;
        r = Math.floor(30 + 70 * (1 - t));
        g = Math.floor(30 + 140 * (1 - t));
        b = Math.floor(80 + 175 * t);
      } else {
        // Hot: yellow to deep red  
        let t = norm;
        r = Math.floor(80 + 175 * t);
        g = Math.floor(80 + 100 * (1 - t));
        b = Math.floor(30 + 50 * (1 - t));
      }
      
      ctx.fillStyle = `rgb(${r},${g},${b})`;
      // Draw larger pixels for better visibility
      ctx.fillRect(pt.x - 3, pt.y - 3, 6, 6);
    }
  }
  
  // Store data for download
  anisotropyData = {
    energyMap: energyMap,
    countMap: countMap,
    nTheta: nTheta,
    nPhi: nPhi,
    samples: samples,
    stats: {
      mean: meanE,
      stdDev: stdDev,
      min: minE,
      max: maxE,
      range: range,
      nSamples: samples.length
    },
    metadata: {
      time: recombinationSnapshot.time,
      generation: recombinationSnapshot.generation,
      gridSize: gridSize
    }
  };
  
  // Display WMAP-style statistics
  // Convert energy to "temperature" in μK (microkelvin) scale
  // Real CMB: T_mean ≈ 2.725K, ΔT ≈ ±100μK
  // We scale our energy to similar proportions
  const T_mean = 2725000; // 2.725K in μK
  const T_scale = 100 / stdDev; // Scale so 1σ ≈ 100μK
  
  const deltaT_min = (minE - meanE) * T_scale;
  const deltaT_max = (maxE - meanE) * T_scale;
  const deltaT_rms = stdDev * T_scale;
  
  // Calculate higher-order statistics
  let skewness = 0, kurtosis = 0;
  for (let s of samples) {
    let z = (s.energy - meanE) / stdDev;
    skewness += z * z * z;
    kurtosis += z * z * z * z;
  }
  skewness /= samples.length;
  kurtosis = kurtosis / samples.length - 3; // Excess kurtosis
  
  // Estimate l_max from angular resolution
  const l_max = Math.min(nTheta, nPhi) * 2;
  
  // Display stats
  const statsDiv = document.getElementById('aniso-stats');
  statsDiv.innerHTML = `
    <b>=== CMB Anisotropy Statistics ===</b><br>
    Mean Temperature: <span>${T_mean.toFixed(0)} μK</span> (2.725 K)<br>
    ΔT Range: <span>${deltaT_min.toFixed(1)}</span> to <span>+${deltaT_max.toFixed(1)} μK</span><br>
    RMS Fluctuation: <span>±${deltaT_rms.toFixed(1)} μK</span><br>
    Skewness: <span>${skewness.toFixed(4)}</span><br>
    Kurtosis (excess): <span>${kurtosis.toFixed(4)}</span><br>
    <br>
    <b>=== Map Properties ===</b><br>
    Resolution: <span>${nTheta}×${nPhi}</span> pixels<br>
    l_max: <span>~${l_max}</span><br>
    Total Samples: <span>${samples.length.toLocaleString()}</span><br>
    <br>
    <b>=== Simulation Info ===</b><br>
    Time: <span>${recombinationSnapshot.time.toFixed(1)} Kyr</span><br>
    Generation: <span>${recombinationSnapshot.generation}</span><br>
    Grid: <span>${gridSize}³</span>
  `;
  
  console.log('Anisotropy: ' + samples.length + ' samples, l~0-' + l_max);
  console.log('ΔT RMS:', deltaT_rms.toFixed(2), 'μK');
}

function downloadAnisotropyData() {
  if (!anisotropyData) {
    alert('No anisotropy data available. Run simulation to recombination first.');
    return;
  }
  
  // Create FITS-like header
  let header = `SIMPLE  =                    T / file conforms to FITS standard
BITPIX  =                  -32 / array data type
NAXIS   =                    2 / number of array dimensions
NAXIS1  =                  ${anisotropyData.nTheta} / longitude dimension
NAXIS2  =                  ${anisotropyData.nPhi} / latitude dimension
CTYPE1  = 'RA---MOL'           / Mollweide projection in RA
CTYPE2  = 'DEC--MOL'           / Mollweide projection in Dec
CRVAL1  =                  0.0 / RA at reference point
CRVAL2  =                  0.0 / Dec at reference point
CRPIX1  =              ${anisotropyData.nTheta/2}.0 / reference pixel X
CRPIX2  =              ${anisotropyData.nPhi/2}.0 / reference pixel Y
CDELT1  =    ${360/anisotropyData.nTheta} / pixel scale in degrees
CDELT2  =    ${180/anisotropyData.nPhi} / pixel scale in degrees
BUNIT   = 'Energy   '           / arbitrary units
DATAMIN =    ${anisotropyData.stats.min.toExponential(10)} / minimum data value
DATAMAX =    ${anisotropyData.stats.max.toExponential(10)} / maximum data value
DATAMEAN=    ${anisotropyData.stats.mean.toExponential(10)} / mean data value
DATASIG =    ${anisotropyData.stats.stdDev.toExponential(10)} / standard deviation
SIMTIME =    ${anisotropyData.metadata.time} / simulation time in Kyr
SIMGEN  =                  ${anisotropyData.metadata.generation} / simulation generation
GRIDSIZE=                  ${anisotropyData.metadata.gridSize} / CA grid size
END
`;
  
  // Pad header to 2880 bytes (FITS requirement)
  while (header.length % 80 !== 0) header += ' ';
  while (header.length % 2880 !== 0) header += ' ';
  
  // Create binary data (float32 array)
  const data = anisotropyData.energyMap;
  const buffer = new ArrayBuffer(header.length + data.length * 4);
  const view = new Uint8Array(buffer);
  
  // Write header
  for (let i = 0; i < header.length; i++) {
    view[i] = header.charCodeAt(i);
  }
  
  // Write data (big-endian float32)
  const dataView = new DataView(buffer, header.length);
  for (let i = 0; i < data.length; i++) {
    dataView.setFloat32(i * 4, data[i], false); // false = big-endian
  }
  
  // Download
  const blob = new Blob([buffer], { type: 'application/octet-stream' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `hqiv_cmb_anisotropy_gen${anisotropyData.metadata.generation}.fits`;
  a.click();
  URL.revokeObjectURL(url);
  
  console.log('Downloaded FITS file with', anisotropyData.stats.nSamples, 'pixels');
}

function showAnisotropy() {
  if (recombinationSnapshot) {
    generateAnisotropyMap();
  } else {
    console.log('Run until recombination');
  }
}

function initThree() {
  scene = new THREE.Scene();
  
  camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 1, 2000);
  camera.position.set(100, 80, 120);
  camera.lookAt(0, 0, 0);
  
  renderer = new THREE.WebGLRenderer({antialias:false});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);
  
  const n = gridSize * gridSize * gridSize;
  const positions = new Float32Array(n * 3);
  const colors = new Float32Array(n * 3);
  
  points = new THREE.Points(
    new THREE.BufferGeometry(),
    new THREE.PointsMaterial({size: CELL_SIZE * 1.2, vertexColors: true, 
                              transparent: true, opacity: 0.9})
  );
  points.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  points.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  scene.add(points);
  
  horizonSphere = new THREE.Mesh(
    new THREE.SphereGeometry(1, 48, 32),
    new THREE.MeshBasicMaterial({color: 0x00ff66, wireframe: true, 
                                 transparent: true, opacity: 0.2})
  );
  scene.add(horizonSphere);
  
  scene.add(new THREE.DirectionalLight(0xffffff, 0.6));
  scene.add(new THREE.AmbientLight(0x303030));
}

function reset() {
  generation = 0;
  simTime = 0;
  recombinationReached = false;
  recombinationSnapshot = null;
  maxStructureSize = 0;
  paused = false;
  document.getElementById('stat-recomb').style.display = 'none';
  document.getElementById('anisotropy').style.display = 'none';
  initArrays();
  updateVisualization();
}

function animate() {
  requestAnimationFrame(animate);
  updateCA();
  renderer.render(scene, camera);
}

function setupEvents() {
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
  
  let dragging = false, prevX = 0, prevY = 0;
  let rotX = 0.4, rotY = 0.6;
  
  function updateCamera() {
    camera.position.x = 140 * Math.sin(rotY) * Math.cos(rotX);
    camera.position.y = 140 * Math.sin(rotX);
    camera.position.z = 140 * Math.cos(rotY) * Math.cos(rotX);
    camera.lookAt(0, 0, 0);
  }
  
  document.addEventListener('mousedown', e => {
    dragging = true;
    prevX = e.clientX;
    prevY = e.clientY;
  });
  
  document.addEventListener('mouseup', () => dragging = false);
  
  document.addEventListener('mousemove', e => {
    if (dragging) {
      let dx = e.clientX - prevX;
      let dy = e.clientY - prevY;
      rotY += dx * 0.005;
      rotX += dy * 0.005;
      rotX = Math.max(-1.5, Math.min(1.5, rotX));
      updateCamera();
      prevX = e.clientX;
      prevY = e.clientY;
    }
  });
  
  document.addEventListener('wheel', e => {
    let dist = camera.position.length();
    dist += e.deltaY * 0.15;
    dist = Math.max(40, Math.min(300, dist));
    camera.position.normalize().multiplyScalar(dist);
  });
  
  document.addEventListener('keydown', e => {
    if (e.code === 'Space') {
      paused = !paused;
      e.preventDefault();
    } else if (e.code === 'KeyR') {
      reset();
    } else if (e.code === 'KeyA') {
      showAnisotropy();
    }
  });
  
  updateCamera();
}

try {
  initThree();
  initArrays();
  updateVisualization();
  setupEvents();
  animate();
  console.log('HQIV 3D CA: 80^3 = 512K cells for l~1200 CMB anisotropy');
  console.log('Auto-pauses at recombination - press A for anisotropy map');
} catch(e) {
  document.getElementById('error').style.display = 'block';
  console.error(e);
}
</script>
</body>
</html>
